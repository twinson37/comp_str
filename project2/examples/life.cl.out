[Board][IO]{rows[Int]}{columns[Int]}{board_size[Int]}{size_of_board(initial[String])[Int]initial.length()}{board_init(start[String])[SELF_TYPE](let (size[Int]<-size_of_board(start)) ((if (= size 15) (rows<-3 columns<-5 board_size<-size) (if (= size 16) (rows<-4 columns<-4 board_size<-size) (if (= size 20) (rows<-4 columns<-5 board_size<-size) (if (= size 21) (rows<-3 columns<-7 board_size<-size) (if (= size 25) (rows<-5 columns<-5 board_size<-size) (if (= size 28) (rows<-7 columns<-4 board_size<-size) (rows<-5 columns<-5 board_size<-size))))))) self))}
[CellularAutomaton][Board]{population_map[String]}{init(map[String])[SELF_TYPE](population_map<-map board_init(map) self)}{print()[SELF_TYPE](let (i[Int]<-0) (let (num[Int]<-board_size) (out_string("\n") (while (< i num) (out_string(population_map.substr(i columns)) out_string("\n") i<-(+ i columns))) out_string("\n") self)))}{num_cells()[Int]population_map.length()}{cell(position[Int])[String](if (< (- board_size 1) position) " " population_map.substr(position 1))}{north(position[Int])[String](if (< (- position columns) 0) " " cell((- position columns)))}{south(position[Int])[String](if (< board_size (+ position columns)) " " cell((+ position columns)))}{east(position[Int])[String](if (= (* (/ (+ position 1) columns) columns) (+ position 1)) " " cell((+ position 1)))}{west(position[Int])[String](if (= position 0) " " (if (= (* (/ position columns) columns) position) " " cell((- position 1))))}{northwest(position[Int])[String](if (< (- position columns) 0) " " (if (= (* (/ position columns) columns) position) " " north((- position 1))))}{northeast(position[Int])[String](if (< (- position columns) 0) " " (if (= (* (/ (+ position 1) columns) columns) (+ position 1)) " " north((+ position 1))))}{southeast(position[Int])[String](if (< board_size (+ position columns)) " " (if (= (* (/ (+ position 1) columns) columns) (+ position 1)) " " south((+ position 1))))}{southwest(position[Int])[String](if (< board_size (+ position columns)) " " (if (= (* (/ position columns) columns) position) " " south((- position 1))))}{neighbors(position[Int])[Int]((+ (+ (+ (+ (+ (+ (+ (if (= north(position) "X") 1 0) (if (= south(position) "X") 1 0)) (if (= east(position) "X") 1 0)) (if (= west(position) "X") 1 0)) (if (= northeast(position) "X") 1 0)) (if (= northwest(position) "X") 1 0)) (if (= southeast(position) "X") 1 0)) (if (= southwest(position) "X") 1 0)))}{cell_at_next_evolution(position[Int])[String](if (= neighbors(position) 3) "X" (if (= neighbors(position) 2) (if (= cell(position) "X") "X" "-") "-"))}{evolve()[SELF_TYPE](let (position[Int]<-0) (let (num[Int]<-num_cells()) (let (temp[String]) ((while (< position num) (temp<-temp.concat(cell_at_next_evolution(position)) position<-(+ position 1))) population_map<-temp self))))}{option()[String]((let (num[Int]) (out_string("\nPlease chose a number:\n") out_string("\t1: A cross\n") out_string("\t2: A slash from the upper left to lower right\n") out_string("\t3: A slash from the upper right to lower left\n") out_string("\t4: An X\n") out_string("\t5: A greater than sign \n") out_string("\t6: A less than sign\n") out_string("\t7: Two greater than signs\n") out_string("\t8: Two less than signs\n") out_string("\t9: A 'V'\n") out_string("\t10: An inverse 'V'\n") out_string("\t11: Numbers 9 and 10 combined\n") out_string("\t12: A full grid\n") out_string("\t13: A 'T'\n") out_string("\t14: A plus '+'\n") out_string("\t15: A 'W'\n") out_string("\t16: An 'M'\n") out_string("\t17: An 'E'\n") out_string("\t18: A '3'\n") out_string("\t19: An 'O'\n") out_string("\t20: An '8'\n") out_string("\t21: An 'S'\n") out_string("Your choice => ") num<-in_int() out_string("\n") (if (= num 1) " XX  XXXX XXXX  XX  " (if (= num 2) "    X   X   X   X   X    " (if (= num 3) "X     X     X     X     X" (if (= num 4) "X   X X X   X   X X X   X" (if (= num 5) "X     X     X   X   X    " (if (= num 6) "    X   X   X     X     X" (if (= num 7) "X  X  X  XX  X      " (if (= num 8) " X  XX  X  X  X     " (if (= num 9) "X   X X X   X  " (if (= num 10) "  X   X X X   X" (if (= num 11) "X X X X X X X X" (if (= num 12) "XXXXXXXXXXXXXXXXXXXXXXXXX" (if (= num 13) "XXXXX  X    X    X    X  " (if (= num 14) "  X    X  XXXXX  X    X  " (if (= num 15) "X     X X X X   X X  " (if (= num 16) "  X X   X X X X     X" (if (= num 17) "XXXXX   X   XXXXX   X   XXXX" (if (= num 18) "XXX    X   X  X    X   XXXX " (if (= num 19) " XX X  XX  X XX " (if (= num 20) " XX X  XX  X XX X  XX  X XX " (if (= num 21) " XXXX   X    XX    X   XXXX " "                         "))))))))))))))))))))))))}{prompt()[Bool]((let (ans[String]) (out_string("Would you like to continue with the next generation? \n") out_string("Please use lowercase y or n for your answer [y]: ") ans<-in_string() out_string("\n") (if (= ans "n") false true))))}{prompt2()[Bool](let (ans[String]) (out_string("\n\n") out_string("Would you like to choose a background pattern? \n") out_string("Please use lowercase y or n for your answer [n]: ") ans<-in_string() (if (= ans "y") true false)))}
[Main][CellularAutomaton]{cells[CellularAutomaton]}{main()[SELF_TYPE]((let (continue[Bool]) (let (choice[String]) (out_string("Welcome to the Game of Life.\n") out_string("There are many initial states to choose from. \n") (while prompt2() (continue<-true choice<-option() cells<-(new CellularAutomaton).init(choice) cells.print() (while continue (if prompt() (cells.evolve() cells.print()) continue<-false)))) self))))}
