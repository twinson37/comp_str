[A]{var[Int]<-0}{value()[Int]var}{set_var(num[Int])[SELF_TYPE](var<-num self)}{method1(num[Int])[SELF_TYPE]self}{method2(num1[Int]num2[Int])[B](let (x[Int]) (x<-(+ num1 num2) (new B).set_var(x)))}{method3(num[Int])[C](let (x[Int]) (x<-(~ num) (new C).set_var(x)))}{method4(num1[Int]num2[Int])[D](if (< num2 num1) (let (x[Int]) (x<-(- num1 num2) (new D).set_var(x))) (let (x[Int]) (x<-(- num2 num1) (new D).set_var(x))))}{method5(num[Int])[E](let (x[Int]<-1) ((let (y[Int]<-1) (while (<= y num) (x<-(* x y) y<-(+ y 1)))) (new E).set_var(x)))}
[B][A]{method5(num[Int])[E](let (x[Int]) (x<-(* num num) (new E).set_var(x)))}
[C][B]{method6(num[Int])[A](let (x[Int]) (x<-(~ num) (new A).set_var(x)))}{method5(num[Int])[E](let (x[Int]) (x<-(* (* num num) num) (new E).set_var(x)))}
[D][B]{method7(num[Int])[Bool](let (x[Int]<-num) (if (< x 0) method7((~ x)) (if (= 0 x) true (if (= 1 x) false (if (= 2 x) false method7((- x 3)))))))}
[E][D]{method6(num[Int])[A](let (x[Int]) (x<-(/ num 8) (new A).set_var(x)))}
[A2I]{c2i(char[String])[Int](if (= char "0") 0 (if (= char "1") 1 (if (= char "2") 2 (if (= char "3") 3 (if (= char "4") 4 (if (= char "5") 5 (if (= char "6") 6 (if (= char "7") 7 (if (= char "8") 8 (if (= char "9") 9 (abort() 0)))))))))))}{i2c(i[Int])[String](if (= i 0) "0" (if (= i 1) "1" (if (= i 2) "2" (if (= i 3) "3" (if (= i 4) "4" (if (= i 5) "5" (if (= i 6) "6" (if (= i 7) "7" (if (= i 8) "8" (if (= i 9) "9" (abort() "")))))))))))}{a2i(s[String])[Int](if (= s.length() 0) 0 (if (= s.substr(0 1) "-") (~ a2i_aux(s.substr(1 (- s.length() 1)))) (if (= s.substr(0 1) "+") a2i_aux(s.substr(1 (- s.length() 1))) a2i_aux(s))))}{a2i_aux(s[String])[Int](let (int[Int]<-0) ((let (j[Int]<-s.length()) (let (i[Int]<-0) (while (< i j) (int<-(+ (* int 10) c2i(s.substr(i 1))) i<-(+ i 1))))) int))}{i2a(i[Int])[String](if (= i 0) "0" (if (< 0 i) i2a_aux(i) "-".concat(i2a_aux((* i (~ 1))))))}{i2a_aux(i[Int])[String](if (= i 0) "" (let (next[Int]<-(/ i 10)) i2a_aux(next).concat(i2c((- i (* next 10))))))}
[Main][IO]{char[String]}{avar[A]}{a_var[A]}{flag[Bool]<-true}{menu()[String](out_string("\n\tTo add a number to ") print(avar) out_string("...enter a:\n") out_string("\tTo negate ") print(avar) out_string("...enter b:\n") out_string("\tTo find the difference between ") print(avar) out_string("and another number...enter c:\n") out_string("\tTo find the factorial of ") print(avar) out_string("...enter d:\n") out_string("\tTo square ") print(avar) out_string("...enter e:\n") out_string("\tTo cube ") print(avar) out_string("...enter f:\n") out_string("\tTo find out if ") print(avar) out_string("is a multiple of 3...enter g:\n") out_string("\tTo divide ") print(avar) out_string("by 8...enter h:\n") out_string("\tTo get a new number...enter j:\n") out_string("\tTo quit...enter q:\n\n") in_string())}{prompt()[String](out_string("\n") out_string("Please enter a number...  ") in_string())}{get_int()[Int]((let (z[A2I]<-(new A2I)) (let (s[String]<-prompt()) z.a2i(s))))}{is_even(num[Int])[Bool](let (x[Int]<-num) (if (< x 0) is_even((~ x)) (if (= 0 x) true (if (= 1 x) false is_even((- x 2))))))}{class_type(var[A])[SELF_TYPE](case var(a[A]=>out_string("Class type is now A\n") b[B]=>out_string("Class type is now B\n") c[C]=>out_string("Class type is now C\n") d[D]=>out_string("Class type is now D\n") e[E]=>out_string("Class type is now E\n") o[Object]=>out_string("Oooops\n")))}{print(var[A])[SELF_TYPE](let (z[A2I]<-(new A2I)) (out_string(z.i2a(var.value())) out_string(" ")))}{main()[Object](avar<-(new A) (while flag (out_string("number ") print(avar) (if is_even(avar.value()) out_string("is even!\n") out_string("is odd!\n")) class_type(avar) char<-menu() (if (= char "a") (a_var<-(new A).set_var(get_int()) avar<-(new B).method2(avar.value() a_var.value())) (if (= char "b") (case avar(c[C]=>avar<-c.method6(c.value()) a[A]=>avar<-a.method3(a.value()) o[Object]=>(out_string("Oooops\n") abort() 0))) (if (= char "c") (a_var<-(new A).set_var(get_int()) avar<-(new D).method4(avar.value() a_var.value())) (if (= char "d") avar<-(new C).[A]method5(avar.value()) (if (= char "e") avar<-(new C).[B]method5(avar.value()) (if (= char "f") avar<-(new C).[C]method5(avar.value()) (if (= char "g") (if (new D).method7(avar.value()) (out_string("number ") print(avar) out_string("is divisible by 3.\n")) (out_string("number ") print(avar) out_string("is not divisible by 3.\n"))) (if (= char "h") (let (x[A]) (x<-(new E).method6(avar.value()) (let (r[Int]<-(- avar.value() (* x.value() 8))) (out_string("number ") print(avar) out_string("is equal to ") print(x) out_string("times 8 with a remainder of ") (let (a[A2I]<-(new A2I)) (out_string(a.i2a(r)) out_string("\n"))))) avar<-x)) (if (= char "j") avar<-(new A) (if (= char "q") flag<-false avar<-(new A).method1(avar.value()))))))))))))))}
